// ① Javascript 为什么是单线程的？
// JavaScript 是单线程语言，是与它的用途有关的
// Javascript 的主要用途是与用户进行交互，以及操作 DOM。
// 这决定了它只能是单线程的
// 因为如果有两个线程，这两个线程一个是在 DOM 的某个节点上添加内容，一个是删除了这个节点
// 那么浏览器就会不知道该以哪个线程为准


// ② 任务队列
// 所有的任务都会被分为两个任务队列，一种是同步任务，一种是异步任务。同步任务指的是，在主线程上执行的任务，只有前一个执行完毕，才能执行下一个任务。
// 异步任务指的是，不进入主线程，而进入另一个“任务队列”，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会被放入主线程中执行。
// 任务执行机制如下：
// (1) 所有同步任务都在主线程上执行，形成了一个“任务栈”
// (2) 主线程之外，还存在一个“任务队列”，只要异步任务的执行有了结果，就在“任务队列”之中放置一个事件
// (3) 只要“执行栈”中的同步任务全部执行完毕，系统就会读取“任务队列”，那些处于等待状态的异步任务就会开始执行


// ③ EventLoop
// 主线程从“任务队列”中读取事件，这个过程是不断循环的，所以整个运行机制又被称为是 Eventloop.

// setTimeout 以及 Promise 执行顺序
// setTimeout(function, 0) 是指某个任务在主线程最早可得的空闲时间执行，也就是说它会在“任务队列”的尾部添加一个事件
// 因此要等到同步任务和“任务队列”中的事件都处理完之后，才会执行，所以 setTimeout 会在 Promise 的后面执行


// ④ 宏任务和微任务
// 宏任务：事件执行队列中的每一个任务都是宏任务，供任务是由 JavaScript 的宿主比如浏览器或者是 Node 发起的
// 优先级：主代码块 > setImmediate > MessageChannel > setTimeout/setInterval

// 微任务：是由 JavaScript 自身发起的
// 优先级：process.nextTick > Promise > MutationObserver
// setTimeout 是宏任务，Promise 是微任务，微任务会在宏任务之前执行